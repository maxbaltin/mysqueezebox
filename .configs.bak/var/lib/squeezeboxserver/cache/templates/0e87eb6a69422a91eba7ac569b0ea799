#------------------------------------------------------------------------
# Compiled template generated by the Template Toolkit version 2.21
#------------------------------------------------------------------------

Template::Document->new({
    METADATA => {
        'name' => '/usr/share/squeezeboxserver/HTML/EN/html/docs/buttons.html',
        'modtime' => '1518618963',
    },
    BLOCK => sub {
        my $context = shift || die "template sub called without context\n";
        my $stash   = $context->stash;
        my $output  = '';
        my $_tt_error;
        
        eval { BLOCK: {
#line 1 "/usr/share/squeezeboxserver/HTML/EN/html/docs/buttons.html"
    $stash->set('pagetitle', 'Button Mapping');
    $output .=  "\n";
#line 2 "/usr/share/squeezeboxserver/HTML/EN/html/docs/buttons.html"
    $stash->set('techinfo', '1');
    $output .=  "\n";
#line 3 "/usr/share/squeezeboxserver/HTML/EN/html/docs/buttons.html"
    $stash->set('lefttoright', '1');
    $output .=  "\n";
#line 4 "/usr/share/squeezeboxserver/HTML/EN/html/docs/buttons.html"
    $output .=  $context->process('helpheader.html');
    $output .=  "\n\n  <h4>Overview</h4>\n  <p>\n    The Player IR interface to the Squeezebox associates human actions \n    (pressing a button on the remote) with functions on the server (jumping to\n    the next song). There are a number of translations, or mappings between the\n    human action and the server function.\n  </p>\n  <p>\n    The remote translates the particular button pressed into a series of pulses\n    of infrared light. The player recieves these pulses, and translates them\n    into a four byte code, which is sent to the server. The server looks up\n    this code in a table and tranlates it into a button name. The button name\n    is then looked up in another table to produce the function which should be\n    called.\n  </p>\n  <p>\n    The button to IR pulse mapping depends on the remote used, and is not generally\n    customizable, although programmable remotes can be used. The IR pulse to code\n    mapping is controlled in the firmware of the player, and cannot be modified\n    without updating that firmware. The code to button name mapping is controlled\n    through <em>.ir</em> files, typically one for each type of remote used to control\n    the player. The final button name to function mapping is controlled through\n    <em>.map</em> files, consisting of a default mapping file, and any custom maps\n    which may have been created.\n  </p>\n  <p>\n    The mapping files, both <em>.ir</em> and <em>.map</em>, are stored in the \n    <strong>IR</strong> subfolder of the folder where the Squeezebox software was\n    installed. Included with the software are two <em>.ir</em> files:\n    <em>jvc_dvd.ir</em> and <em>Slim_Devices_Remote.ir</em> which handle the codesets\n    sent by the JVC DVD player (which is the codeset most commonly used by the\n    player prior to the production of the product specific remotes) and the\n    product specific remote respectively. One <em>.map</em> file(<em>Default.map</em>),\n    representing the default mapping is included.\n  </p>\n  <hr>\n  <h4>Mappings</h4>\n  <h5>Code to Button Name</h5>\n  <p>\n    The code to button name mapping is contained within <em>.ir</em> files located\n    in the <strong>IR</strong> subfolder of the Logitech Media Server folder. The files\n    consist of lines with the button name followed by an equals sign (<strong>=</strong>)\n    followed by the IR code in hex (no 0x necessary). Everything after a <strong>#</strong>\n    is considered a comment. Leading and trailing whitespace is ignored, as is whitespace\n    around the <strong>=</strong> and preceding the <strong>#</strong>. The\n    <strong>=</strong> and <strong>#</strong> characters are not allowed within the\n    button name, but embedded whitespace (except newlines) is allowed. Due to the\n    implementation of button pressing styles (explained below), the period\n    (<strong>.</strong>) is not recommended for use within a button name.\n  </p>\n  <p>\n    Multiple codes can map to the same button name. On the other hand, if\n    a particular code is repeated within the same file, only the last mapping\n    will actually be used.\n  </p>\n  <p>\n    The server will load all <em>.ir</em> files within the <strong>IR</strong>\n    subfolder. Individual mappings can be disabled for a particular player by\n    using the <em>disabledirsets</em> client array preference. This is\n    configurable from the web interface by following the\n    &quot;";
#line 66 "/usr/share/squeezeboxserver/HTML/EN/html/docs/buttons.html"
    
    # FILTER
    $output .=  do {
        my $output = '';
        my $_tt_filter = $context->filter('string')
                  || $context->throw($context->error);
    
    $output .=  'REMOTE_SETTINGS';
        
        &$_tt_filter($output);
    };
    
    $output .=  "&quot; \n    link from the &quot;";
#line 67 "/usr/share/squeezeboxserver/HTML/EN/html/docs/buttons.html"
    
    # FILTER
    $output .=  do {
        my $output = '';
        my $_tt_filter = $context->filter('string')
                  || $context->throw($context->error);
    
    $output .=  'PLAYER_SETTINGS';
        
        &$_tt_filter($output);
    };
    
    $output .=  "&quot; page. This can be useful if\n    you have JVC equipment co-located with the player and want to prevent\n    it from reacting to remote signals intended for the other equipment.\n  </p>\n  <p>\n    Examples:<br />\n    <pre>\nplay = 0000f732\nplay = 0000f7d6 #alternate code for play, with a comment\n    pause     =      0000f7b2   # extra spacing ignored\nplay=this = 0000f123 #BAD! = not allowed in button names\nB# = 0000f7c6        #BAD! # also not allowed in button names\n</pre>\n  </p>\n  <h5>Button Name to Function</h5>\n  <p>\n    The button name to function mapping is contained within <em>.map</em> files\n    located in the <strong>IR</strong> subfolder of the Logitech Media Server folder.\n    The files consist of lines with the button name followed by an equals sign\n    (<strong>=</strong>) followed by the function. Everything after a\n    <strong>#</strong> is considered a comment. Leading and trailing whitespace\n    is ignored, as is whitespace around the <strong>=</strong> and preceding the\n    <strong>#</strong>. The <strong>=</strong> and <strong>#</strong> characters\n    are not allowed within either the button name or the function, but embedded\n    whitespace (except newlines) is allowed. Due to the implementation of button\n    pressing styles (explained below), the period (<strong>.</strong>) is not\n    recommended for use within a button name, but would be fine for inclusion\n    in a function. Similarly, use of the underscore (<strong>_</strong>) is not\n    recommended in naming functions, but is fine for button names.\n  </p>\n  <p>\n    The map file is divided up into a number of sections corresponding to the\n    various modes of operation, plus a <strong>&#91;common&#93;</strong> section whose\n    mappings apply to all modes. Sections start with the name of the section\n    enclosed in square brackets (<strong>&#91;&#93;</strong>). Mode classes, \n    prefixed by all caps (eg, INPUT.list) will first match to a section headed \n    by <strong>&#91;INPUT.list&#93;</strong> then, if no matches found will take \n    functions from an <strong>&#91;input&#93;</strong> section.  \n  <p>\n    Multiple button names can map to the same function. On the other hand, if\n    a particular button name (including pressing style) is repeated within the\n    same section, only the last mapping in that section will actually be used.\n  </p>\n  <p>\n    Button pressing styles are indicated by appending a period (<strong>.</strong>)\n    to the end of the button name, followed by the desired style.\n  </p>\n  <p>\n    Functions can be passed a single parameter by appending an underscore\n    (<strong>_</strong>) to the end of the function name, followed by the parameter \n  </p>\n  <p>\n    Examples:\n    <pre>\n&#91;common&#93;\narrow_down = down\narrow_down.repeat = down #alternate pressing style for same function\n    rew.single     =     jump_rew     #this function uses a parameter, spacing unimportant\nfwd.single = jump_fwd #same function, different parameter\n&#91;off&#93;\narrow_down = dead #in a different section now, so ok to redefine button names\n</pre>\n  <hr />\n  <h4>Timing</h4>\n  <p>\n    When a code is first received by the server, the plain button mapping is\n    triggered. Also, a timer is set to go off in IRSINGLETIME seconds (currently\n    0.256).\n  </p>\n  <p>\n    If the button on the remote is held down, the server will receive additional\n    codes identical to the initial one. If the repeated codes are each received\n    within IRMINTIME seconds (currently 0.128) of each other, the button.repeat\n    mapping is triggered for each repeated code. If one of those repeated codes\n    happens between IRHOLDTIME (currently 0.512) and IRHOLDTIME + IRMINTIME seconds,\n    the button.hold mapping is triggered.\n  </p>\n  <p>\n    When either IRSINGLETIME seconds pass or a code comes in more than IRMINTIME\n    seconds from the previous code, the pending timer is fired. If the code is\n    different from the code which initiated the timer, the mapping for button.single\n    (for the first code) is triggered. If the new code is the same as the old one,\n    the mapping for button.double is triggered.\n  </p>\n  <p>\n    If the timer fired as a result of the time elapsing, then it must be determined\n    if the button is still being held. This is the case if the last code received\n    was received within the last IRMINTIME seconds. If the button is no longer being\n    held, the mapping for button.single is triggered. Otherwise the timer is\n    rescheduled for another IRSINGLETIME seconds, or for however long it takes to\n    make the total time be IRHOLDTIME seconds. The same checks apply for the next\n    time the timer is fired.\n  </p>\n  <p>\n    After IRHOLDTIME seconds have passed, the timer will no longer trigger the\n    button.single or button.double mappings. From that point forward, the mapping\n    triggered will be button.hold_release when it is finally determinied that the\n    button is no longer being held.\n  </p>\n  <p>\n    Multiple button pressing styles can be included in the mapping with the use of the\n    '*' wildcard. Thus button.* will match all styles.  Specific sytles will override the \n    for that style.\n  </p>\n  <hr>\n  <p>\n    More to come...\n  </p>\n";
#line 175 "/usr/share/squeezeboxserver/HTML/EN/html/docs/buttons.html"
    $output .=  $context->process('helpfooter.html');
        } };
        if ($@) {
            $_tt_error = $context->catch($@, \$output);
            die $_tt_error unless $_tt_error->type eq 'return';
        }
    
        return $output;
    },
    DEFBLOCKS => {

    },
});
