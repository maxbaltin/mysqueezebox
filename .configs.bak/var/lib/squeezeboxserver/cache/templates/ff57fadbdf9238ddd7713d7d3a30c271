#------------------------------------------------------------------------
# Compiled template generated by the Template Toolkit version 2.21
#------------------------------------------------------------------------

Template::Document->new({
    METADATA => {
        'modtime' => '1518618963',
        'name' => '/usr/share/squeezeboxserver/HTML/EN/html/docs/display.html',
    },
    BLOCK => sub {
        my $context = shift || die "template sub called without context\n";
        my $stash   = $context->stash;
        my $output  = '';
        my $_tt_error;
        
        eval { BLOCK: {
#line 1 "/usr/share/squeezeboxserver/HTML/EN/html/docs/display.html"
    $stash->set('pagetitle', 'Display API');
    $output .=  "\n";
#line 2 "/usr/share/squeezeboxserver/HTML/EN/html/docs/display.html"
    $stash->set('techinfo', '1');
    $output .=  "\n";
#line 3 "/usr/share/squeezeboxserver/HTML/EN/html/docs/display.html"
    $stash->set('lefttoright', '1');
    $output .=  "\n";
#line 4 "/usr/share/squeezeboxserver/HTML/EN/html/docs/display.html"
    $output .=  $context->process('helpheader.html');
    $output .=  "\n<h4>Display Hash</h4>\n\n<p>The format of the display hash for 7.0 is the same as for 6.5.</p>\n\n<p>The standard 2 line display with 2 overlays is described as:</p>\n\n<pre>my \$hash = {\n   'line'    => [ 'Text to appear on top line',\n                  'Text to appear on bottom line and possibly scroll' ],\n   'overlay' => [ 'Overlay to appear at right of top line',\n                  'Overlay to appear at right of bottom line' ],\n}</pre>\n\n<p>Arrays are used for each component of the display as the rendering code\nsupports more than 2 lines of text.  This is restricted to 2 lines for\nSBG and 3 for SB2/SB3/Tranporter at present [requires appropriate\nfonts].  For example:</p> \n\n<pre>my \$hash = {\n   'line'    => [ 'Line1',\n                  'Line2',\n                  'Line3' ],\n}</pre>\n\n<p>The examples given on the rest of this page only include 2 lines,\nbut 3 lines may be used for all line, overlay and center components.</p>\n\n<p>Note that scrolling is possible on any line of the display if it is\ntoo long, but this is disabled for the top line.</p>\n\n<p>Centered text is described as:</p>\n\n<pre>my \$hash = {\n   'center' => [ 'Text to be centered on line 1',\n                 'Text to be centered on bottom line' ],\n}</pre>\n\n<p>Symbols are typically displayed in one of the overlays but can exist in\nany component.  Individual symbols can be added to the hash using\n\$client->symbols():</p>\n\n<pre>my \$hash = {\n   'line'    => [ 'Text to appear on top line',\n                  'Text to appear on bottom line and possibly scroll' ],\n   'overlay' => [ \$client->symbols('notesymbol') ],\n}</pre>\n\n<p>See \$client->symbols() below for valid symbol names.</p>\n\n<p>6.5 added support for 2 screens for use with Transporter players.\nThe second display is described within the 'screen2' hash component.\nScreen 1 may be described at the root of the hash, or within a\n'screen1' component:</p>\n\n<pre>my \$hash = {\n   'line'    => [ 'Screen 1 Line 1',\n                  'Screen 1 Line 2' ],\n   'screen2' => {\n       'line' => [ 'Screen 2 Line 1',\n                   'Screen 2 Line 2' ]\n   }\n}</pre>\n\n<p>or</p>\n\n<pre>my \$hash = {\n   'screen1' => {\n       'line'    => [ 'Screen 1 Line 1',\n                      'Screen 1 Line 2' ],\n   },\n   'screen2' => {\n       'line' => [ 'Screen 2 Line 1',\n                   'Screen 2 Line 2' ]\n   }\n}</pre>\n\n<p>As screen1 may appear at the root of the hash, the empty hash represents\na blank screen1.</p>\n\n\n<h5>Player Specifics</h5>\n\n<p>All player types are intended to display in as similar way as\npossible. However there are some specifics due to the limited screen\nresolution of some hardware:</p>\n\n<p><b>Text Displays (Slimp3/Squeezebox):</b></p>\n\n<p>In two line mode overlays are displayed.  If center exists for a\nline then this takes precedence over line such that only the\ncentered text and overlay are displayed.</p>\n\n<p>Overlays truncate line so that the overlay is always displayed.\nIn the case of line[0], text is simply truncated so the overlay fits.\nIn the case of line[1], text will potentially scroll within the region of\nthe screen to the left of overlay[1].  Centered text will also be\ntruncated by overlays if they appear in the same position.</p>\n\n<p>In single line mode overlays are not displayed by default.  Again\ncentered text takes precedence such that if center[1] exists then line[1]\nwill not be displayed.</p>\n\n<p><b>Graphic Displays (Squeezebox-Graphics, Squeezebox2/3, Transporter):</b></p>\n\n<p>Graphics players attempt to display all components at the same time, so\nthat both center and line are displayed.  Overlays truncate\nline in the same way as for text players.  However centered text is not\ntruncated by the overlays.  As the resulting bitmaps for each text\ncomponent are displayed on top of each other, it is the calling\nfunction's responsibility to avoid overlapping text - e.g. centered\ntext overlapping overlays.</p>\n\n<h5>Bitmaps</h5>\n\n<p>Graphics players may also display a bitmap:</p>\n\n<pre>my \$hash = {\n   'bits' => \$bitmap,\n}</pre> \n\n<p>Where \$bitmap is a byte string which defines a bitmap of appropriate\nsize for the display. The bitmap will be displayed on top of any other\ntext defined in the same display hash.</p>\n\n<p>Squeezebox 1 G takes a 280 x 2 byte bitmap, with the first byte defining\nthe top 8 bits of the left most display column the second byte defining\nthe lower 8 bits. The 3rd & 4th byte describe the second column etc.</p>\n\n<p>Squeezebox 2, 3 & Transporter take a 320 x 4 byte bitmap, with the\nfirst byte defining the top 8 bits of the first column, the next 3\ndefining the rest of the first column etc.</p>\n\n<h5>Fonts</h5>\n\n<p>The display hash can define a font element to define the font to be\nused for a display.  If it exists it takes precedence over the current\nfont for the player.</p>\n\n<p>A simple font element is used to define a single font to use for all\ncomponents of the display:</p>\n\n<pre>my \$hash = {\n   'line' => [ 'Text to appear on top line',\n               'Text to appear on bottom line and possibly scroll' ],\n   'fonts' => {\n       'graphic-320x32' => 'standard',\n       'graphic-280x16' => 'small',\n       'text'           => 2,\n   }\n}</pre>\n\n<p>As different player use different fonts, it is normal to define the\nfont for each type of player:</p>\n\n<ul>\n	<li>'graphic-320x32' is the font used for Squeezebox2/3/Transporter\n	<li>'graphic-280x16' is the font used for Squeezebox1-Graphics\n	<li>'text' defines the number of lines to display on\n	Slimp3/Squeezebox1\n</ul>\n\n<p>The font element may also take a more detailed definition to allow\nmore complex displays to be defined.</p>\n\n<p>For graphics players, the specific font for each of\nline/overlay/center can defined.  If the font for only some components\nare defined, other components take the current active font for the player.</p>\n\n<p>The following fixes the font for overlay[0], but leaves all other fonts\nas the currently active player font:</p>\n\n<pre>my \$hash = {\n   ...\n   'fonts' => { \n       'graphic-280x16'  => { 'overlay' => [ 'small.1' ] },\n       'graphic-320x32'  => { 'overlay' => [ 'standard.1' ] },\n       }\n}</pre>\n\n<p>Note: the font name should be the font file name including the line\nnumber.  It is specified as a string (rather than a reference to a\nstring, as used in the 6.2 hash.)</pre>\n\n<p>By setting non standard fonts for each component it is possible to\ncreate new types of display.  Care should be taken in setting the\noverlay fonts to match the line font as the point at which lines are\ntruncated is based on the respective overlays.</p>\n\n<p>For text players, the font element may define the number of lines and\nalso force display of overlays in single line mode:</p>\n\n<pre>my \$hash = {\n   ...\n   'fonts' => { \n       'text'  => { 'lines' => 1,\n                    'displayoverlays' => 1\n		  },\n       }\n}</pre>\n\n<ul>\n	<li>'lines' defines whether 1 line (doubled) or 2 line mode should be used.\n	<li>'displayoverlays' set to 1 forces overlays to be displayed in two line,\nmode.\n</ul>\n\n<h5>Scrolling</h5>\n\n<p>For all players, text in line[1] will scroll if it is too long to fit\ninto the space to the left of overlay[1].  With 7.0/6.5 on graphic\nplayers, scrolling may also occur on line[2].  The default operation of\nscrolling for a player is set via preference 'scrollMode', but can be\noverridden by the parameter sent to update.  It is no longer\noverridden by a component in the display hash.</p>\n\n<p>Normal scrolling of line[1] shows as much of line[1] as will fit to the\nleft of overlay[1].  This is displayed without scrolling for the\n'scrollPause' interval.  Line[1] then rotates to the point when the\nstart of line[1] is displayed again.  At this point the display\npauses again before continuing the rotation.  With 7.0/6.5 scrolling may\nbe either right to left or left to right.  This is automatically\nselected so that Hebrew text scrolls left to right.</p>\n\n<p>During scrolling, if update is called with a display hash which\nchanges non scrolling components these are updated without\ninterrupting scrolling.  This allows scrolling to continue while\nelapsed times etc are updated, for example in the Now Playing screen.</p>\n\n<h5>Ticker Scrolling</h5>\n\n<p>Ticker scrolling is designed to be used by screensavers such as the\nRssNews.  It changes the scrolling operation to that of a ticker\ndisplay - text appears from the right edge, scrolls across the screen\nand off the left side.  It does not rotate in the manner of normal\nscrolling.</p>\n\n<p>With 7.0/6.5 ticker scrolling supports scrolling on any line of the\ndisplay and uses a new component of the display hash.  Items are added\no the ticker by calling update with a display hash such as:</p>\n\n<pre>my \$hash = {\n   'line'  => [ 'Non scrolling top line' ],\n   'ticker => [ undef, 'New item to be added to ticker' ],\n}</pre>\n\n<p>Note that the hash should not define text for a line[x] if it also\ndefines text for ticker[x] as both will be displayed at once.</p>\n\n<p>If line/overlay components change during ticker mode these are\ndisplayed immediately.  However text defined in the ticker component\nwill be added to the ticker queue and will appear once items currently in\nthe ticker queue have been displayed.</p>\n\n<p>The function: \$client->scrollTickerTimeLeft()\n[\$client->display->scrollTickerTimeLeft()] is used to find the\ncurrent length of the ticker queue and is used to optimise when new\nitems are added to the queue:</p>\n\n<pre>my (\$complete, \$queue) = \$client->scrollTickerTimeLeft();</pre>\n\n<p>Where \$complete is the approx number of seconds left before all text\ndisappears off the left hand side of the display.  \$queue is the\napprox number of seconds worth of text which is queued up but has not\nyet appeared on the right edge of the display.</p>\n\n<p>A lines function may use this to decide whether to return undef or\ntext for a ticker component.  If undef is returned, nothing is added to\nthe ticker queue allowing it to drain.</p>\n\n<p>For example to maintain a ticker using a lines function which is\ncalled once per second:</p>\n\n<pre>sub lines {\n   my \$client = shift;\n   my (\$complete, \$queue) = \$client->scrollTickerTimeLeft();\n   \n   my \$text = 'Whatever you want to add to the ticker';\n\n   return( {\n      'line'   => [ 'Fixed top line' ],\n      'ticker' => [ undef, (\$queue < 1) ? \$text : undef ],\n   });\n}</pre>\n\n<hr>\n<h4>Display Functions</h4>\n\n<p>As of 7.0/6.5 all display functions are methods of the display object\nrather than the client object.  The display object is stored in the client\nobject and is returned by \$client->display().</p>\n\n<p>All common display methods may still be accessed via client methods\nas wrappers are included to call the display object.  Note however if\nyou call display functions which are not part of the api below, these\nmethods will have moved to the display object.</p>\n\n<p>Displays are sent to the screen via one of the display functions:</p>\n\n<h5>\$client->update()</h5>\n\n<p>This is the normal way of updating the display.  Updated is normally\ncalled with no params and in this case the lines function registered\nfor the current mode is called to determine the display hash.</p>\n\n<p>Update can be called with a display hash to display something other\nthan the current lines immediately:</p>\n\n<pre>\$client->update( {\n   'line' => [ 'line 1 display',\n               'line 2 display' ],\n} );</pre>\n\n<p>However as the server may call \$client->update() to refresh the\ndisplay this is not recommended.  It is normal to use the lines\nfunction to return the display and call \$client->update() to use it.</p>\n\n<p>If a plugin wishes to update the display on a regular basis, this is\nbest done by setting the following in the setMode function:</p>\n<pre>\$client->param('modeUpdateInterval', X);</pre>\n\n<p>Where X defines the number of seconds between each update.  The server\nwill automatically call update every X seconds whilst in this mode.</p>\n\n<h5>\$client->showBriefly()</h5>\n\n<p>This is used to display a message on the screen for a short\nperiod of time, before returning to the normal display of the mode.</p>\n\n<p>showBriefly should always be called with a display hash and one or more\noptional parameters.  The optional parameters may either be positional\nparameters or named parameters in a parameter hash.</p>\n\n<pre>\$client->showBriefly(\$hash, \$duration, \$firstline, \$blockupdate, \$scrolltoend, \$brightness, \$callback, \$callbackargs)\nor \n\$client->showBriefly(\$hash, \n                     { 'duration'     => \$duration, \n                       'firstline'    => \$firstline, \n                       'block'        => \$blockupdate,\n                       'scroll'       => \$scrolltoend,\n                       'brightness'   => \$brightness,\n                       'callback'     => \$callback,\n                       'callbackargs' => \$callbackargs } )</pre>\n<ul>\n	<li>\$hash - the display hash\n	<li>\$duration - number of seconds to display for (defaults to 1)\n	<li>\$firstline - display only line[0] if in single line mode (otherwise displays line[1] in single line mode)\n	<li>\$blockupdate - block display so that calls to update during	\$duration do not cancel the showBriefly display (defaults to false)\n	<li>\$scrolltoend - if line is too long scroll display and continue until whole line is seen.  This overrides duration.\n	<li>\$brightness - brightness to display at ('powerOn', 'powerOff', 'idle' or brightness value) \n	<li>\$callback - function to call when animation is done, including scrolling.\n	<li>\$callbackargs - callback arguments.\n\n</ul>\n\n<p>For example:</pre>\n\n<pre>\$client->showBriefly( {\n   'line'       => [ \$line1, \$line2 ],\n   'overlay'    => [ \$client->symbols('notesymbol') ],\n}, { 'duration' => 5, 'block' => 1 } );</pre>\n\n<p>Displays two lines plus an overlay for 5 seconds and is not cancelled by\nupdates during this time.</p>\n\n<p>Note that as showBriefly now takes a display hash, there is no need to use\n\$client->renderOverlay() to build a display to send to showBriefly</p>\n\n<h5>\$client->block()</h5>\n\n<p>This is used to display a message for a period of time with a spinning\nactivity notification in overlay[0].  The message is displayed using the\n'block' mode so that it is not interrupted and is only cleared by a\ncall to \$client->unblock().</p>\n\n<pre>\$client->block(\$hash)</pre>\n\n<ul><li>\$hash - display hash</ul>\n\n<p>For example:</p>\n\n<pre>\$client->block( {\n   'line' => [ string('PLAYER_NEEDS_UPGRADE_1'), \n               string('PLAYER_NEEDS_UPGRADE_2') ],\n   'fonts' => { \n      'graphic-320x32' => 'standard',\n      'graphic-280x16' => 'small',\n      'text'           => 2,\n      }\n});</pre>\n\n<p>This forces the font so that two lines are displayed and displays two strings\nuntil \$client->unblock() is called.</p>\n\n<p>[block also takes \$line1, \$line2 for backwards compatibility]<p>\n\n<h5>Lines</h5>\n\n<p>A mode's lines function should return the display hash to display when\n\$client->update() is called.</p>\n\n<p>A simple lines function would be:</p>\n\n<pre>sub lines {\n    my \$client = shift;\n\n    return {\n       'line'    => [ 'Line1 text',\n                      'Line2 text' ],\n       'overlay' => [ \$client->symbols('notesymbol') ],\n    };\n}</pre>\n\n<p>A more complex lines function which specifies the fonts would be:</p>\n\n<pre>sub lines {\n    my \$client = shift;\n    my \$args   = shift;\n\n    return {\n       'line'      => [ 'Line1 text', 'Line2 text' ],\n       'overlay'   => [ \$client->symbols('bell') ],\n       'fonts'      => { \n           'graphic-280x16'  => { 'overlay' => [ 'small.1' ] },\n           'graphic-320x32'  => { 'overlay' => [ 'standard.1' ] },\n           'text' =>            { 'lines' => 2,\n                                  'displayoverlays' => 1,\n                                  },\n           },\n    };\n}</pre>\n\n<p>Note: A lines function which returns a display hash is responsible\nfor converting symbol names to symbol characters.  The lines function\nshould therefore call \$client->symbols() on any text which contains\nsymbols prior to adding to the display hash.</p>\n\n<p>Note: A lines function may be passed an args hash to give information\nrelating to the caller.  When called by menu transition code, the key 'trans'\ndefines the animation which is calling the lines function.  This allows\nthe display to be altered on per transition basis.</p>\n\n<h5>\$client->symbols()</h5>\n\n<p>\$client->symbols() is used to convert the names of symbols to the\ngraphic character representing the symbol itself.  As of 6.2 the\npreferred use of \$client->symbols() is as a replacement for\nSlim::Display::Display:symbol to specify individual symbols.  However\nit can also be used to parse a complete text line and convert symbol\ntokens (created by Slim::Display::Display::symbol) into the symbol\ncharacter.</p>\n\n<p>Preferred use:</p>\n\n<pre>return {\n   'line'    => [ 'text '.\$client->symbols('bell').' more text' ],\n   'overlay' => [ \$client->symbols('bell') ],\n}</pre>\n\n<p>Valid symbol names are currently:\n<ul>\n	<li>'notesymbol'\n	<li>'rightarrow'\n	<li>'cursor'\n	<li>'mixable'\n	<li>'bell'\n	<li>'mixable'\n	<li>'circle' *\n	<li>'filledcircle' *\n	<li>'square' *\n	<li>'filledsquare' *\n	<li>'bell'\n	<li>'progress1'\n	<li>'progress2'\n	<li>'progress3'\n	<li>'progress1e'\n	<li>'progress2e'\n	<li>'progress3e'\n	<li>'progressEnd'\n</ul>\n\n<p>* Only available on graphics displays<p>\n\n<p>Use of custom characters extends this list with custom entries -\nsee Custom Fonts below.</p>\n\n<h5>\$client->curLines()</h5>\n\n<p>\$client->curLines() returns a display hash using the current lines\nfunction.  This is equivalent to the display that would result from\ncalling \$client->update().<p>\n\n<p>As of 6.5 this method replaces Slim::Display::Display::curLines()\nwhich is depreciated.  Note that it always returns a display hash\neven if the lines function itself does not return a display hash.</p>\n\n<h5>\$client->curDisplay()</h5>\n\n<p>\$client->curDisplay() returns a display hash containing the text\ncomponents of the current display.</p>\n\n<p>Note curDisplay returns a display hash including the screen name ('screen1'\nand 'screen2') and all line, overlay, center and font components on the\ncurrent screen.  This is different from previous versions.</p> \n\n<p>The difference between \$client->curDisplay() and \$client->curLines()\nis that \$client->curLines() makes a call to the mode's lines function\nand hence potentially gets a new display, whereas\n\$client->curDisplay() returns what is currently being displayed.  In\nthe case of two screen players this includes what is on both screens,\neven if the current lines function only covers one screen.</p>\n\n<hr>\n<h4>Menu Transitions</h4>\n\n<p>The scrolling menu transitions which make up the slim user\ninterface are controlled by push and bump animation commands. Push\nanimations are used for transition to new menu screens.  Bump\nanimations are used to bump the screen against the edge, normally when\nthe end of a menu structure is reached.</p>\n\n<h5>\$client->pushLeft(\$start, \$end), \$client->pushRight(\$start, \$end)</h5>\n\n<p>Pushes the old screen off the left/right side of the display and replaces it\nwith a new screen.</p>\n\n<ul>\n	<li>\$start - undef or display hash for old screen\n	<li>\$end - undef or display has for new screen\n</ul>\n<p>SB2 does not use \$start as it uses the existing displayed screen\nfor \$start.  As of 6.2, \$start may be set to undef for other players.\nIn this case the server uses the last displayed screen for \$start.</p>\n\n<p>As of 6.2 \$end may also be set to undef.  In this case, the server\nwill call the current lines function to define \$end.  It is therefore\nacceptable to use e.g. \$client->pushLeft() to carry out a menu transition.</p>\n\n<h5>\$client->pushUp(\$end), \$client->pushDown(\$end)</h5>\n<ul>\n	<li>\$end - undef or display hash for new screen\n</ul>\n\n<p>On SB2 this scrolls the bottom line (or all text if in one line\nmode) to move to the next menu or list item.  On text and SBG players it\nsimply calls \$client->update() to display a new screen with the new\ndisplay.  As \$end can only be set for SB2/SB3/Transporter it is not\nnormally used.  The new screen to display is therefore defined by the\ncurrent lines function.  Normally called as e.g. \$client->pushUp().</p>\n\n<h5>\$client->bumpLeft(), \$client->bumpRight()</h5>\n<h5>\$client->bumpUp(), \$client->bumpDown()</h5>\n\n<p>Used to bump the current screen against the edge of the display to\nindicate that no additional menu items are available.</p>\n\n<hr>\n<h4>Custom Characters</h4>\n\n<p>Custom characters may be defined for both character and graphic\ndisplay players. These enable lines functions to display customised\nsymbols as icons and to build up complex displays for e.g. games like\nSlimTris.</p>\n\n<p>Note that as of 6.5, display code is dynamically loaded based on\nthe types of player attached.  This means that custom characters must\nbe defined once a player has attached - this is different from\nprevious versions.</p>\n\n<h5>Character Displays</h5>\n\n<p>The character display hardware uses a fixed font definition for all\nnormal characters (See <a\nhref=\"http://www.slimdevices.com/downloads/datasheets/vfd-chars.gif\"\ntarget=\"displaychars\">here</a>).</p>\n<p>It also supports definition of up to 8 custom characters per\ndisplay.  These may be defined by plugins and used anywhere on the\ndisplay.</p>\n\n<p>Logitech Media Server allows you to define many custom characters using:\nSlim::Display::Text::setCustomChar().</p>\n\n<p>Each display screen can use up to 8 custom characters.  If more\ncustom characters exist on a screen they will be replaced with a blank\ncharacter.  [NB Logitech Media Server also uses custom characters for the\npredefined symbols which also count towards this limit.]</p>\n\n<p>Each custom character is 5 pixels wide and 7 pixels high plus an\nunderline which is either on or off [equivalent of a single wide\npixel].</p>\n\n<p>For example to define a custom character to be called 'my-icon':</p>\n\n<pre>Slim::Display::Text::setCustomChar( 'my-icon', ( \n		0b00000000, \n		0b00000000, \n		0b00000000, \n		0b00000000, \n		0b00011110, \n		0b00011111, \n		0b00011111,\n\n		0b00000000\n		));\n</pre>	\n<p>Note: The 3 most signifcant bits of each line are not used.</p>\n\n<p>Custom characters may then be added to a display via\n\$client->symbols():</p>\n<pre>\n\$display = {\n    'line' => [ 'text ' . \$client->symbols('my-icon'). ' more text' ],\n};\n</pre>\n\n<p>Custom characters do not work in 1 line mode on character\ndisplays.</p>\n\n<p>Note: Slim::Display::Text::setCustomChar() should only be\ncalled once the text display code is loaded - e.g. from the setMode\nwithin a plugin, see SlimTris for an example.</p>\n\n<h5>Graphics Displays</h5>\n\n<p>Graphic displays may display custom characters through the use of\ncustom font files.</p>\n\n<p>Custom font files define a bitmap to use for each character in the\ncustom font.  The format of font files is described <a\nhref=\"fonts.html\">here</a>.  For plugins, custom font files are\nnormally placed in the plugin's root directory.</p>\n\n<p>The function Slim::Display::Graphics::setCustomChar() is used to\nregister a name to associate with specific custom characters.  This may be\nused to name each character in a custom font file.</p>\n\n<p>Once custom characters have been defined they may be included\nwithin display strings via \$client->symbols('character name').</p>\n\n<p>For example:</p>\n\n<pre>\nSlim::Player::Graphics::setCustomChar( 'my-icon', chr(2), 'icon.1' );\n</pre>\n\n<p>This registers the symbol name 'my-icon' for character chr(2) within the font file\n'icon.1'.  This may then be included within a display using:<p>\n\n<pre>\n\$display = {\n    'line' => [ 'text ' . \$client->symbols('my-icon') . ' more text' ],\n};\n</pre>\n\n<p>This allows custom characters to be used in the same way for\ncharacter and graphics displays.</p>\n\n<p>If a custom font is to be used for all characters within a display\ncomponent, it is more efficient to define that component to use a\nspecific font within the display hash and not register the font name\nas part of the custom character name.</p>\n\n<pre>\nSlim::Player::Graphics::setCustomChar( 'my-icon', chr(2) );\n\n\$display = {\n    'overlay' => [ \$client->symbols('my-icon') ],\n    'fonts'   => { 'graphic-320x32'  => { 'overlay' => [ 'icon.1' ] } },\n};\n</pre>\n\n<p>Note: Slim::Player::Graphics::setCustomChar should only be\ncalled once a graphics player is attached - e.g. by calling from the\nsetMode of a plugin if it has not been previously called [see SlimTris\nfor an example of this for text custom characters].</p>\n\n<hr>\n<h4>Two Screen Displays</h4>\n\n<p>Transporter introduces two screens which may display text or\nvisualizers.</p>\n\n<p>Modes may display text on two screens by returning the new display\nhash with a 'screen2' component.  If a mode returns both screens, it\nshould also set the mode param 'screen2' to indicate to the server\nthat it may need to clear screen2 when the mode exits.\nInclude the following in the setMode function for the mode:</p>\n\n<pre>\n\$client->param('screen2', 'mymodename');\n</pre>\n\n<p>Where 'mymodename' can be any string other than 'periodic' (which\nis reserved).</p>\n\n<p>A mode may choose to override the current visualizer mode and\nalways use screen2.  In this case it should also set the 'visu' param in its\nsetMode function to [0]:</p>\n\n<pre>\n\$client->param('visu', [0]);\n</pre>\n\n<p>Alternatively the mode can check the current visualizer mode and\nonly return screen2 information if it is in extended text mode.  To do\nthis call:</p>\n\n<pre>\n\$display->showExtendedText()  [\$client->display->showExtendedText()]\n</pre>\n\n<p>This returns true if the player display supports 2 screens and it\nis in extended text mode at present.</p>\n\n<p>To check whether the current display has 2 screens, call the\nfollowing:</p>\n\n<pre>\n\$display->hasScreen2()        [\$client->display->hasScreen2()]\n</pre>\n\n<p>If the player is showing extended text information and the current\nmode does not set the 'screen2' mode param, the server will display\nalternative information on the second screen.  In this mode, the right\nhand screen is updated once a second using the lines function registered\nwith \$client->lines2periodic().</p>\n\n<p>By default the Now Playing screen is registered with\nline2periodic.  It is possible to override this in a plugin by adding\na notify callback to listen for new clients connecting and resetting\nthe line2periodic function at this point.  For example:</p>\n\n<pre>\nsub initPlugin {\n    Slim::Control::Request::subscribe( \\&newClient, [['client']], [['new']] );\n}\n\nsub newClient {\n    my \$client = shift->client || return;\n    \$client->lines2periodic(\\&lines);\n}\n\nsub lines {\n    my \$client = shift;\n    my \$args   = shift;\n    return {'screen2'}->{\n        'line' => [ 'top line', 'bottom line' ]\n    };\n}\n</pre>\n\n<p>Note that the lines function will be called with \$args->{'screen2'}\nset to indicate that the response is for screen2 only.</p>\n\n<hr></hr>\n<h4>Custom Server Mode Displays</h4>\n\n<p>7.0/6.5 supports custom lines functions for the volume display and\nplaylist mode.  This allows a plugin to alter the built in screen\ndisplays for changing volume and playlist/now playing displays.</p>\n\n<p>A plugin should register alternative lines function at client\nconnect time with the client methods customVolumeLines and\ncustomPlaylistLines.</p>\n\n<p>To avoid server status messages appearing on top of a custom\nscreen, a plugin can also turn off the common play/stop/pause status\nmessages by setting \$client->suppressStatus().  Setting this to 'all'\nwill suppress both display updates and popups on jive.  Setting it to\nanother true value will only suppress display updates.</p>\n\n<pre>\nsub initPlugin {\n    Slim::Control::Request::subscribe( \\&newClient, [['client']], [['new']] );\n}\n\nsub newClient {\n    my \$client = shift->client || return;\n    \$client->customVolumeLines( \\&volumeLines );\n    \$client->customPlaylistLines( \\&playlistLines );\n    \$client->suppressStatus(1);\n}\n\nsub volumeLines {\n    my \$client = shift;\n    my \$vol = shift;\n\n    if (!defined \$vol && \$client->param('valueRef')) {\n        \$vol = \${\$client->param('valueRef')};\n    }\n\n    # \$vol is a value 0..100\n}\n\nsub playlistLines {\n    my \$client = shift;\n\n    # see Slim::Buttons::Playlist::lines for details\n}\n</pre>\n\n<p></p>\n";
#line 806 "/usr/share/squeezeboxserver/HTML/EN/html/docs/display.html"
    $output .=  $context->process('helpfooter.html');
    $output .=  "\n";
        } };
        if ($@) {
            $_tt_error = $context->catch($@, \$output);
            die $_tt_error unless $_tt_error->type eq 'return';
        }
    
        return $output;
    },
    DEFBLOCKS => {

    },
});
